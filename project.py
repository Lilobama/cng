# -*- coding: utf-8 -*-
"""project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/102DOrQwLZlrCqERUEZnr2jjzivXCaL8Q
"""

!pip install librosa

!pip install SciPy

import librosa as lb
import numpy as np
import pandas as pd
from google.colab import files
uploaded = files.upload()
filename = list(uploaded.keys())[0]
genre_profiles = {
    "classical": {
        "tempo": (50, 120),
        "centroid": (300, 2000),
        "chroma_complexity": (0.10, 0.25),
    },
    "rock": {
        "tempo": (110, 170),
        "centroid": (2000, 6000),
        "chroma_complexity": (0.05, 0.12),
    },
    "edm": {
        "tempo": (120, 150),
        "centroid": (2500, 7000),
        "chroma_complexity": (0.02, 0.08),
    },
    "hiphop": {
        "tempo": (80, 115),
        "centroid": (300, 2500),
        "chroma_complexity": (0.04, 0.4),
    },
    "jazz": {
        "tempo": (90, 160),
        "centroid": (800, 3500),
        "chroma_complexity": (0.12, 0.30),
    },
    "pop": {
        "tempo": (90, 130),
        "centroid": (1500, 4000),
        "chroma_complexity": (0.03, 0.09),
    },
    "metal": {
        "tempo": (130, 200),
        "centroid": (3500, 8000),
        "chroma_complexity": (0.04, 0.10),
    },
    "ambient": {
        "tempo": (60, 100),
        "centroid": (200, 1500),
        "chroma_complexity": (0.01, 0.05),
    },
}

class Music:

    def __init__(self, path):
        self.path = path

    def temp(self):
        self.y, self.sr = lb.load(self.path, mono=True)
        self.tempo, _ = lb.beat.beat_track(y=self.y, sr=self.sr)
        return self.tempo
    def spectre(self):
        self.spectr = lb.feature.spectral_centroid(y=self.y, sr=self.sr)[0]
        return np.mean(self.spectr)
    def chtome(self):
        harmonic, percussive = lb.effects.hpss(self.y)
        self.chroma = lb.feature.chroma_stft(y=harmonic, sr=self.sr)
        return self.chroma

    def features(self):
        self.chroma_complexity = np.mean(np.std(self.chroma, axis=1))
        return {
            "tempo": self.tempo,
            "centroid": np.mean(self.spectr),
            "chroma_complexity": self.chroma_complexity,
        }
    def guess_genre(self):
      features = self.features()

      tempo = features["tempo"]
      centroid = features["centroid"]
      chroma_complexity = features["chroma_complexity"]

      best_genre = "unknown"
      best_score = -1

      for genre, prof in genre_profiles.items():
          score = 0
          t_min, t_max = prof["tempo"]
          c_min, c_max = prof["centroid"]
          сo_min, co_max = prof['chroma_complexity']
          if t_min <= tempo <= t_max:
              score += 1
          if c_min <= centroid <= c_max:
              score += 1
          if сo_min <= chroma_complexity <= co_max:
              score += 1

          if score > best_score:
              best_score = score
              best_genre = genre

      return best_genre



track = Music(filename)
track.temp()
track.spectre()
track.chtome()
track.features()
print(track.guess_genre())



import librosa as lb
import numpy as np
import pandas as pd
from google.colab import files

from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import LabelEncoder, StandardScaler
from sklearn.model_selection import train_test_split

print("Загрузите музыкальный файл для анализа:")
up = files.upload()
fn = list(up.keys())[0]

class Music:
    def __init__(self, pt):
        self.pt = pt
        self.yy = None
        self.sr = None

    def load_and_process(self):
        td = lb.get_duration(filename=self.pt)
        st = max(0.0, (td - 30.0) / 2.0)
        self.yy, self.sr = lb.load(self.pt, mono=True, offset=st, duration=30.0)

        ch = lb.feature.chroma_stft(y=self.yy, sr=self.sr)
        self.ch_m = np.mean(ch)
        self.ch_v = np.var(ch)

        rm = lb.feature.rms(y=self.yy)
        self.rm_m = np.mean(rm)
        self.rm_v = np.var(rm)

        ce = lb.feature.spectral_centroid(y=self.yy, sr=self.sr)
        self.ce_m = np.mean(ce)
        self.ce_v = np.var(ce)

        bw = lb.feature.spectral_bandwidth(y=self.yy, sr=self.sr)
        self.bw_m = np.mean(bw)
        self.bw_v = np.var(bw)

        ro = lb.feature.spectral_rolloff(y=self.yy, sr=self.sr)
        self.ro_m = np.mean(ro)
        self.ro_v = np.var(ro)

        zc = lb.feature.zero_crossing_rate(self.yy)
        self.zc_m = np.mean(zc)
        self.zc_v = np.var(zc)

        yh, yp = lb.effects.hpss(self.yy)
        self.yh_m = np.mean(yh)
        self.yh_v = np.var(yh)
        self.yp_m = np.mean(yp)
        self.yp_v = np.var(yp)

        tr, _ = lb.beat.beat_track(y=self.yy, sr=self.sr)
        self.tm = float(np.mean(tr))

        mf = lb.feature.mfcc(y=self.yy, sr=self.sr, n_mfcc=20)
        self.mf_m = np.mean(mf, axis=1)
        self.mf_v = np.var(mf, axis=1)

    def get_features(self, fc):
        fd = {
            'chroma_stft_mean': self.ch_m, 'chroma_stft_var': self.ch_v,
            'rms_mean': self.rm_m, 'rms_var': self.rm_v,
            'spectral_centroid_mean': self.ce_m, 'spectral_centroid_var': self.ce_v,
            'spectral_bandwidth_mean': self.bw_m, 'spectral_bandwidth_var': self.bw_v,
            'rolloff_mean': self.ro_m, 'rolloff_var': self.ro_v,
            'zero_crossing_rate_mean': self.zc_m, 'zero_crossing_rate_var': self.zc_v,
            'harmony_mean': self.yh_m, 'harmony_var': self.yh_v,
            'perceptr_mean': self.yp_m, 'perceptr_var': self.yp_v,
            'tempo': self.tm
        }

        for i in range(20):
            fd[f'mfcc{i+1}_mean'] = self.mf_m[i]
            fd[f'mfcc{i+1}_var'] = self.mf_v[i]

        return [fd.get(n, 0) for n in fc]

try:
    dt = pd.read_csv("features_30_sec.csv")
except FileNotFoundError:
    print("Ошибка: Файл 'features_30_sec.csv' не найден.")
    dt = pd.DataFrame()

if not dt.empty:
    dt = dt.drop(columns=['filename', 'length'], errors='ignore')

    gs = dt['label']
    le = LabelEncoder()
    yy = le.fit_transform(gs)

    xx = dt.drop(columns=['label'])
    fc = xx.columns.tolist()

    xt, xtt, yt, ytt = train_test_split(xx, yy, test_size=0.2, random_state=42)

    sc = StandardScaler()
    xt = sc.fit_transform(xt)
    xtt = sc.transform(xtt)

    md = RandomForestClassifier(n_estimators=300, max_depth=25, random_state=42)
    md.fit(xt, yt)

    print(f"Точность модели на тестовых данных: {md.score(xtt, ytt):.3f}")

    print("\nАнализ загруженного трека...")
    tk = Music(fn)
    tk.load_and_process()

    tf = tk.get_features(fc)
    tf = sc.transform([tf])

    pi = md.predict(tf)[0]
    pg = le.inverse_transform([pi])[0]

    pr = md.predict_proba(tf)[0]
    cn = np.max(pr) * 100

    print(f"\nРезультат: {pg}")
    print(f"Уверенность: {cn:.2f}%")

    t3 = np.argsort(pr)[-3:][::-1]
    print("Другие вероятные жанры:")
    for ix in t3:
        if ix != pi:
            g = le.inverse_transform([ix])[0]
            print(f"- {g}: {pr[ix]*100:.2f}%")